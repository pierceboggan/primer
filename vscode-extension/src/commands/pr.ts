import * as vscode from "vscode";
import { createPullRequest, isPrimerFile } from "../services.js";
import { getGitHubToken } from "../auth.js";
import { getWorkspacePath } from "./analyze.js";
import { getGitRepository } from "../gitUtils.js";

export async function prCommand(): Promise<void> {
  const workspacePath = getWorkspacePath();
  if (!workspacePath) return;

  const repository = getGitRepository(workspacePath);
  if (!repository) return;

  // Detect remote owner/repo
  const origin = repository.state.remotes.find((r) => r.name === "origin");
  const originUrl = origin?.pushUrl ?? origin?.fetchUrl;
  if (!originUrl) {
    vscode.window.showErrorMessage("Primer: No origin remote found.");
    return;
  }

  const match = originUrl.match(/github\.com[:/]([^/]+)\/(.+?)(?:\.git)?$/);
  if (!match) {
    vscode.window.showErrorMessage("Primer: Could not parse GitHub owner/repo from origin remote.");
    return;
  }
  const [, owner, repo] = match;

  const branch = repository.state.HEAD?.name;
  if (!branch) {
    vscode.window.showErrorMessage("Primer: Could not determine current branch (detached HEAD?).");
    return;
  }

  // Detect default branch by checking remote refs for origin/main or origin/master
  const refs = await repository.getRefs({ pattern: "refs/remotes/origin/*" });
  const hasMain = refs.some((r) => r.name === "origin/main");
  const hasMaster = refs.some((r) => r.name === "origin/master");
  const base = hasMain ? "main" : hasMaster ? "master" : "main";

  if (branch === base) {
    vscode.window.showErrorMessage(
      "Primer: Cannot create PR from the default branch. Check out a feature branch first."
    );
    return;
  }

  const title = await vscode.window.showInputBox({
    prompt: "Pull request title",
    value: `Add Primer AI configs for ${repo}`
  });
  if (!title) return;

  await vscode.window.withProgress(
    { location: vscode.ProgressLocation.Notification, title: "Primer: Creating pull request…" },
    async () => {
      try {
        const token = await getGitHubToken();

        // Check for Primer files in both unstaged and staged changes
        const allChanges = [
          ...repository.state.workingTreeChanges,
          ...repository.state.indexChanges
        ];
        // Deduplicate by URI (a file can appear in both working tree and index)
        const seen = new Set<string>();
        const changes = allChanges.filter((c) => {
          const key = c.uri.toString();
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });
        if (changes.length > 0) {
          const primerChanges = changes.filter((c) =>
            isPrimerFile(vscode.workspace.asRelativePath(c.uri, false))
          );

          if (primerChanges.length === 0) {
            vscode.window.showWarningMessage("Primer: No Primer-generated files to commit.");
            return;
          }

          // Warn if there are non-Primer files already staged that would be included in the commit
          const stagedNonPrimer = repository.state.indexChanges.filter(
            (c) => !isPrimerFile(vscode.workspace.asRelativePath(c.uri, false))
          );
          if (stagedNonPrimer.length > 0) {
            const proceed = await vscode.window.showWarningMessage(
              `Primer: ${stagedNonPrimer.length} non-Primer file(s) are already staged and will be included in the commit.`,
              "Continue",
              "Cancel"
            );
            if (proceed !== "Continue") return;
          }

          await repository.add(primerChanges.map((c) => c.uri));
          await repository.commit(title);
        }

        // Push — ensures the branch exists on the remote even if changes were already committed
        await repository.push("origin", branch, true);

        // Guard against empty PRs when branch has no diff from base
        const baseRefs = await repository.getRefs({ pattern: `refs/remotes/origin/${base}` });
        const headRefs = await repository.getRefs({ pattern: `refs/remotes/origin/${branch}` });
        if (
          baseRefs[0]?.commit &&
          headRefs[0]?.commit &&
          baseRefs[0].commit === headRefs[0].commit
        ) {
          const proceed = await vscode.window.showWarningMessage(
            "Primer: No new changes detected. The PR may be empty.",
            "Continue",
            "Cancel"
          );
          if (proceed !== "Continue") return;
        }

        const prUrl = await createPullRequest({
          token,
          owner,
          repo,
          title,
          body: "Generated by Primer VS Code extension.",
          head: branch,
          base
        });

        const openAction = "Open in Browser";
        const action = await vscode.window.showInformationMessage(
          `Primer: Pull request created.`,
          openAction
        );
        if (action === openAction && prUrl.startsWith("https://")) {
          vscode.env.openExternal(vscode.Uri.parse(prUrl));
        }
      } catch (err) {
        vscode.window.showErrorMessage(
          `Primer: PR creation failed — ${err instanceof Error ? err.message : String(err)}`
        );
      }
    }
  );
}
