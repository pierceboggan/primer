import path from "path";

import chalk from "chalk";

import type { RepoAnalysis } from "../services/analyzer";
import { analyzeRepo } from "../services/analyzer";
import { safeWriteFile } from "../utils/fs";
import { prettyPrintSummary } from "../utils/logger";
import type { CommandResult } from "../utils/output";
import { outputResult, outputError, shouldLog } from "../utils/output";

type AnalyzeOptions = {
  json?: boolean;
  quiet?: boolean;
  output?: string;
  force?: boolean;
};

export async function analyzeCommand(
  repoPathArg: string | undefined,
  options: AnalyzeOptions
): Promise<void> {
  const repoPath = path.resolve(repoPathArg ?? process.cwd());

  try {
    const analysis = await analyzeRepo(repoPath);

    // Write to file when --output is specified
    if (options.output) {
      const outputPath = path.resolve(options.output);
      const ext = path.extname(outputPath).toLowerCase();
      if (ext !== ".json" && ext !== ".md") {
        outputError(
          `Unsupported output format: ${ext || "(no extension)"}. Use .json or .md`,
          Boolean(options.json)
        );
        return;
      }
      const content =
        ext === ".md" ? formatAnalysisMarkdown(analysis) : JSON.stringify(analysis, null, 2);

      const { wrote, reason } = await safeWriteFile(outputPath, content, Boolean(options.force));
      if (!wrote) {
        const why = reason === "symlink" ? "path is a symlink" : "file exists (use --force)";
        outputError(`Skipped ${outputPath}: ${why}`, Boolean(options.json));
        return;
      }
      if (options.json) {
        const result: CommandResult<typeof analysis> = {
          ok: true,
          status: "success",
          data: analysis
        };
        outputResult(result, true);
        return;
      }
      if (shouldLog(options)) {
        process.stderr.write(chalk.green(`✓ Report saved: ${outputPath}`) + "\n");
      }
      return;
    }

    if (options.json) {
      const result: CommandResult<typeof analysis> = {
        ok: true,
        status: "success",
        data: analysis
      };
      outputResult(result, true);
    } else if (shouldLog(options)) {
      prettyPrintSummary(analysis);
    }
  } catch (error) {
    outputError(error instanceof Error ? error.message : String(error), Boolean(options.json));
  }
}

export function formatAnalysisMarkdown(analysis: RepoAnalysis): string {
  const lines: string[] = [];
  const repoName = path.basename(analysis.path);

  lines.push(`# Repository Analysis: ${repoName}`);
  lines.push("");
  lines.push("## Overview");
  lines.push("");
  lines.push(`| Property | Value |`);
  lines.push(`| --- | --- |`);
  lines.push(`| Path | \`${analysis.path}\` |`);
  lines.push(`| Git repository | ${analysis.isGitRepo ? "Yes" : "No"} |`);
  lines.push(`| Languages | ${analysis.languages.join(", ") || "Unknown"} |`);
  lines.push(`| Frameworks | ${analysis.frameworks.join(", ") || "None detected"} |`);
  lines.push(`| Package manager | ${analysis.packageManager ?? "Unknown"} |`);
  if (analysis.isMonorepo) {
    lines.push(
      `| Monorepo | ${analysis.workspaceType ?? "yes"} (${analysis.apps?.length ?? 0} apps) |`
    );
  }

  if (analysis.apps && analysis.apps.length > 0) {
    lines.push("");
    lines.push("## Applications");
    lines.push("");
    lines.push("| Name | Ecosystem | TypeScript | Path |");
    lines.push("| --- | --- | --- | --- |");
    for (const app of analysis.apps) {
      const rel = path.relative(analysis.path, app.path).replace(/\\/gu, "/") || ".";
      lines.push(
        `| ${app.name} | ${app.ecosystem ?? "—"} | ${app.hasTsConfig ? "Yes" : "No"} | \`${rel}\` |`
      );
    }
  }

  if (analysis.areas && analysis.areas.length > 0) {
    lines.push("");
    lines.push("## Areas");
    lines.push("");
    lines.push("| Name | Source | Pattern |");
    lines.push("| --- | --- | --- |");
    for (const area of analysis.areas) {
      const pattern = Array.isArray(area.applyTo) ? area.applyTo.join(", ") : area.applyTo;
      lines.push(`| ${area.name} | ${area.source} | \`${pattern}\` |`);
    }
  }

  lines.push("");
  lines.push(`---`);
  lines.push(`*Generated by [Primer](https://github.com/microsoft/agent-init)*`);
  lines.push("");

  return lines.join("\n");
}
